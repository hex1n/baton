---
name: plan-first-implement
description: >
  Use after the plan is APPROVED. Execute the plan mechanically,
  following the todo checklist item by item. Supports context-slice
  mode for focused per-item execution. Do not deviate from the plan.
  If something unexpected happens, stop and escalate.
  Can run standalone (Layer 0) on any approved plan.md.
---
# Plan-First Implementation

Implementation is mechanical execution of an approved plan. Your job is
to follow the plan exactly, not to improve it. Creativity belongs in the
planning phase. Implementation belongs to discipline.

## Quick Reference

| Attribute        | Value                                                              |
|------------------|--------------------------------------------------------------------|
| Trigger          | plan.md is APPROVED and contains `## Todo`                        |
| Input            | plan.md todo items (in order), optionally with context slices      |
| Output           | Code changes + checked todo boxes + verification evidence          |
| Side effects     | Modifies source files as specified by todo items                   |
| Sole responsibility | Mechanical execution of approved plan                          |
| Exit condition   | All todo items checked; ready for verification-gate                |

## Mode Behavior

| Mode               | Cross-skill deps | Output path                       | Gate check |
|--------------------|-------------------|-----------------------------------|------------|
| PURE STANDALONE    | Skip              | Files per plan spec               | Skip       |
| PROJECT STANDALONE | Skip              | Files per plan spec               | Skip       |
| WORKFLOW MODE      | Enforced          | Files per plan spec + task dir    | Enforced   |

---

## Standalone mode (Layer 0)

This skill can run on any plan.md that has `<!-- STATUS: APPROVED -->`
and a `## Todo` section. Use `baton implement <plan.md> [--item N]`
to invoke it directly.

When running standalone:
- Operates on the specified plan.md file.
- Context slices are used if present in the same file or as slices.md.
- No phase-lock enforcement (but the discipline still applies).

## Prerequisites

Before you start:
- Confirm plan.md has `<!-- STATUS: APPROVED -->`
- Confirm plan.md contains a `## Todo` section with checklist items.
  If the todo section is missing, the approval flow was not completed —
  go back to plan-first-plan Phase 2 to generate the todo.
- Read the entire plan.md to refresh context (unless using context slices)
- If either check fails, STOP. Do not implement.

## Context-slice mode (preferred)

When context slices are available (generated by the context-slice skill),
use them instead of the full plan for per-item execution:

### Subagent injection protocol

For each todo item, the subagent receives:
1. **Context slice** (REQUIRED) — the self-contained context package
2. **Hard constraints** (REQUIRED if available) — from hard-constraints.md
3. **Completion summary of dependencies** (if item has dependencies)

The subagent does **NOT** receive:
- The full plan.md
- The annotation log
- Other items' context slices
- The research.md

### Slice-mode workflow

```
For each todo item (in order):
    ├─ Read #slice-N for this item
    ├─ Check dependencies: all predecessors complete? → proceed
    ├─ Implement exactly what the slice specifies
    ├─ Verify using the slice's Verify criteria
    ├─ Scope check: did I modify only "Files to modify"?
    │   ├─ Yes → mark complete
    │   └─ No → STOP, revert extra changes
    └─ Mark todo item complete: - [x]
```

### Fallback to full-plan mode

If no context slices exist, use full plan.md as context with a warning:

```
⚠️ No context slices found. Using full plan.md as context.
For better quality on large plans, run: baton slice <plan.md>
```

## Process (full-plan mode)

Announce: "I'm implementing the approved plan, starting with todo item 1."

For each todo item:

### Step 1: Read the item
What file, what change, what verification.

### Step 2: Implement exactly what it says
No more, no less.
⚠️ Checkpoint: Are you about to "improve" something not in the plan? → Unplanned changes = unreviewed bugs. Implement the plan only.

### Step 3: Verify
Run the verification step specified in the todo item.
⚠️ Checkpoint: Are you skipping verification because "this is taking too long"? → Escalate to Level 3 instead of skipping.

### Step 4: Mark complete
Check the box in plan.md: `- [x] 1. ...`

### Step 5: Move to next item
In order. Do not skip ahead.

## After all items complete

1. Run the full verification suite (load verification-gate skill).
2. Once verification passes, announce: "Implementation and verification
   complete. Ready for code review."
3. **Do not self-initiate code review.** Review is an independent phase
   in the workflow. In WORKFLOW MODE, `detect_phase` will detect
   verification completion and `baton next` will guide to loading the
   code-reviewer skill. In standalone mode, suggest the human run
   `baton review`.

## When verification fails

If verification-gate finds test failures or build errors:
1. Identify which todo item(s) caused the failure
2. Apply the escalation ladder (below)
3. Re-run verification after fixing
4. Do NOT report success until verification passes

## When review finds BLOCKING issues

If code-reviewer reports BLOCKING findings:
1. The fix is a **plan amendment**, not freestyle coding. Add a section
   to plan.md: `## Post-review fixes` listing what to change.
2. **Regenerate affected slices.** If context slices exist, regenerate
   slices affected by the fixes.
3. Fix each BLOCKING item with the same discipline as todo items.
4. **Re-run verification-gate** — remove `TASK-STATUS: DONE` if present.
5. Re-run code-reviewer on the fixes only.
6. If significant design changes are needed, escalate to the human.

**Review fix limit:** If BLOCKING issues persist after 2 rounds,
stop and escalate. Repeated failures usually indicate a design problem.

## Escalation ladder

**Level 1: Single-file fix** — Isolated, obvious. Correct inline, note it.

**Level 2: Multi-file revert** — Affects multiple files. Revert, report,
resume from last successful item.

**Level 3: Scope reduction** — Retried twice, still failing. Propose
minimum viable subset. **Never reduce scope without human approval.**

**Level 4: Full abort** — Approach is fundamentally wrong. Revert all,
explain why, reset `<!-- STATUS: DRAFT -->`, ask human to re-review.

**Never spend more than 15 minutes on a failing approach without
escalating to the next level.**

## Rationalizations to watch for

| You think | Why it's wrong | Do this instead |
| :--- | :--- | :--- |
| "I'll improve this while I'm here" | Unplanned changes = unreviewed bugs | Implement the plan. Note improvements for a future task. |
| "This todo item is wrong, I'll fix it my way" | The plan was approved. Deviating breaks the contract. | Stop. Add a note. Ask the human. |
| "I'll do items out of order for efficiency" | Order may encode dependencies | Follow the order unless impossible |
| "The tests can wait until the end" | Each item specifies its own verification | Verify after each item |
| "I'll skip verification, this is taking too long" | Skipping verification = shipping untested code | Escalate to Level 3 instead |
| "Let me read the full plan for context" (slice mode) | Your scope is this one item | Read only the slice |
| "The slice says not to modify X, but it would be better" | Slice boundaries prevent scope creep | Report it, don't change it |
| "I should start the code review now" | Review is a separate phase with its own skill | Announce readiness, let workflow trigger review |
