#!/usr/bin/env bash
# baton ‚Äî Baton CLI (v2.1)

set -euo pipefail
trap '' PIPE

# ‚îÄ‚îÄ Color Utilities ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
BOLD='\033[1m'
RESET='\033[0m'

green() { echo -e "${GREEN}‚úì${RESET} $1"; }
red()   { echo -e "${RED}‚úó${RESET} $1"; }
warn()  { echo -e "${YELLOW}‚ö†${RESET} $1"; }
bold()  { echo -e "${BOLD}$1${RESET}"; }

# ‚îÄ‚îÄ Path Resolution ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

resolve_global_root() {
    if [ -n "${BATON_GLOBAL:-}" ]; then
        echo "${BATON_GLOBAL}"
        return
    fi
    local candidate
    candidate="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
    if [ -d "$candidate/skills" ]; then
        echo "$candidate"
        return
    fi
    echo "$HOME/.baton"
}

resolve_repo_root() {
    local dir
    dir="$(pwd)"
    while [ "$dir" != "/" ]; do
        if [ -d "$dir/.baton" ] && { [ -f "$dir/.baton/project-config.json" ] || [ -d "$dir/.baton/tasks" ]; }; then
            echo "$dir"
            return
        fi
        dir="$(dirname "$dir")"
    done
    pwd
}

GLOBAL_ROOT="$(resolve_global_root)"
REPO_ROOT="$(resolve_repo_root)"
PROJECT_DIR="$REPO_ROOT/.baton"
TASKS_DIR="$PROJECT_DIR/tasks"
ACTIVE_FILE="$PROJECT_DIR/active-task"

# ‚îÄ‚îÄ Version ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

VERSION_FILE="$GLOBAL_ROOT/version.txt"
if [ -f "$VERSION_FILE" ]; then
    VERSION="$(cat "$VERSION_FILE")"
else
    VERSION="unknown"
fi

# ‚îÄ‚îÄ Layer Detection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

detect_layer() {
    if [ ! -d "$PROJECT_DIR" ]; then echo "0"; return; fi
    if [ -f "$ACTIVE_FILE" ]; then
        if [ -f "$PROJECT_DIR/project-config.json" ]; then echo "2"; else echo "1"; fi
    else
        if [ -f "$PROJECT_DIR/project-config.json" ]; then echo "2"; else echo "0"; fi
    fi
}

# ‚îÄ‚îÄ Platform Detection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

detect_platforms() {
    local platforms=""
    if [ -d "$REPO_ROOT/.cursor" ]; then platforms+="cursor "; fi
    if [ -d "$REPO_ROOT/.claude" ] || [ -d "$HOME/.claude" ]; then platforms+="claude-code "; fi
    if [ -d "$REPO_ROOT/.agents" ]; then platforms+="codex "; fi
    echo "${platforms:-unknown}"
}

# ‚îÄ‚îÄ Task & Phase (v2.1: expanded state machine) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Covers all 9 phases: research, plan, annotation, approved, slice,
# implement, verify, review, done
# Detection priority: highest specificity first.

detect_phase() {
    local task_id="$1"
    local task_dir="$TASKS_DIR/$task_id"

    if [ ! -d "$task_dir" ]; then echo "not-started"; return; fi
    if [ -f "$task_dir/.abandoned" ]; then echo "abandoned"; return; fi

    local research="$task_dir/research.md"
    local plan="$task_dir/plan.md"
    local verification="$task_dir/verification.md"
    local review="$task_dir/review.md"

    # ‚îÄ‚îÄ Terminal: done (verification DONE + review exists without BLOCKING) ‚îÄ‚îÄ
    if [ -f "$verification" ] && grep -q "TASK-STATUS: DONE" "$verification" 2>/dev/null; then
        if [ -f "$review" ]; then
            if grep -q "BLOCKING" "$review" 2>/dev/null; then
                echo "review (blocking issues)"
            else
                echo "done"
            fi
        else
            echo "review"
        fi
        return
    fi

    # ‚îÄ‚îÄ Review phase: verification exists but no DONE yet ‚îÄ‚îÄ
    if [ -f "$verification" ]; then
        if [ -f "$review" ]; then
            if grep -q "BLOCKING" "$review" 2>/dev/null; then
                echo "review (blocking issues)"
            else
                echo "done"
            fi
        else
            echo "review"
        fi
        return
    fi

    # ‚îÄ‚îÄ Research phase ‚îÄ‚îÄ
    if [ ! -f "$research" ]; then echo "research (not started)"; return; fi

    local confirmed=false
    if grep -q "RESEARCH-STATUS: CONFIRMED" "$research" 2>/dev/null; then
        confirmed=true
    fi

    if [ ! -f "$plan" ]; then
        if $confirmed; then echo "plan (ready)"; else echo "research (draft)"; fi
        return
    fi

    # ‚îÄ‚îÄ Plan exists ‚îÄ‚îÄ
    if grep -q "STATUS: APPROVED" "$plan" 2>/dev/null; then
        # Approved ‚Üí check for Todo
        if ! grep -q "## Todo" "$plan" 2>/dev/null; then
            echo "approved (generating todo)"
            return
        fi
        # Todo exists ‚Üí check for Context Slices
        if ! grep -q "## Context Slices" "$plan" 2>/dev/null; then
            echo "slice"
            return
        fi
        # Todo + Slices exist ‚Üí implement or verify
        if grep -q "^- \[ \]" "$plan" 2>/dev/null; then
            echo "implement"
        else
            echo "verify"
        fi
        return
    fi

    # ‚îÄ‚îÄ Plan not approved ‚îÄ‚îÄ
    if grep -A 1000 "## Annotation log" "$plan" 2>/dev/null | grep -q "### Round"; then
        echo "annotation"
        return
    fi
    echo "plan (draft)"
}

# ‚îÄ‚îÄ Commands ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

cmd_install() {
    local target="$HOME/.baton"
    if [ -d "$target/skills" ]; then
        echo "Updating existing installation at $target"
    else
        echo "Installing Baton global layer to $target"
    fi

    if [ "$GLOBAL_ROOT" = "$target" ]; then
        echo "Already installed at target location."
        green "Baton v${VERSION} at $target"
        return 0
    fi

    for subdir in skills hooks prompts docs tests; do
        if [ -d "$GLOBAL_ROOT/$subdir" ]; then
            rm -rf "$target/$subdir"
            cp -R "$GLOBAL_ROOT/$subdir" "$target/"
        fi
    done

    # v2.1: also install workflow-protocol.md
    if [ -f "$GLOBAL_ROOT/workflow-protocol.md" ]; then
        cp "$GLOBAL_ROOT/workflow-protocol.md" "$target/workflow-protocol.md"
    fi

    mkdir -p "$target/bin"
    cp "${BASH_SOURCE[0]}" "$target/bin/baton"
    chmod +x "$target/bin/baton"
    if [ -f "$GLOBAL_ROOT/version.txt" ]; then
        cp "$GLOBAL_ROOT/version.txt" "$target/version.txt"
    else
        echo "$VERSION" > "$target/version.txt"
    fi

    green "Baton v${VERSION} installed to $target"
    echo
    echo "Next steps:"
    echo "  1. Add to PATH: export PATH=\"$target/bin:\$PATH\""
    echo "  2. Configure Claude Code hooks:"
    echo "     cp $target/hooks/claude-settings.example.json ~/.claude/settings.json"
    echo "  3. In a project repo: baton init"
}

cmd_init() {
    local baton_dir="$(pwd)/.baton"
    if [ -f "$baton_dir/project-config.json" ]; then
        warn "Project already initialized. Run 'baton doctor' to check."
        return 0
    fi

    mkdir -p "$baton_dir/governance" "$baton_dir/tasks/_task-template/reviews" "$baton_dir/scratch"

    if [ ! -f "$baton_dir/project-config.json" ]; then
        cat > "$baton_dir/project-config.json" << 'EOF'
{
  "stack": "",
  "commands": {
    "compile": "",
    "test_unit": "",
    "test_integration": null,
    "lint": null
  },
  "constraints": {
    "stable_contracts": [],
    "require_review_for": []
  },
  "regression": {
    "suites": [],
    "always_run": ["compile", "lint"],
    "scope_match_strategy": "glob"
  },
  "agents_md_extra": ""
}
EOF
    fi

    if [ ! -f "$baton_dir/review-checklists.md" ]; then
        cat > "$baton_dir/review-checklists.md" << 'EOF'
# Project Review Checklists

Add project-specific review items here. The code-reviewer skill
reads this file and applies every applicable item during review.
Delete the examples below and replace with your project's rules.

## Example: Data changes
- [ ] Schema changes are backward compatible

## Example: Security
- [ ] No secrets in code
EOF
    fi

    if [ ! -f "$baton_dir/governance/hard-constraints.md" ]; then
        cat > "$baton_dir/governance/hard-constraints.md" << 'EOF'
# Hard Constraints

## Universal (from Baton)

### HC-000: Do not write source code before plan is APPROVED
- **Added:** project init
- **Reason:** Enforced by phase-lock hook
- **Scope:** all source files
- **Verify:** phase-lock.sh hook
- **Last-validated:** (auto)
- **Status:** ‚úÖ Active

## Project-specific
Add your project's non-negotiable rules here. Use the format:

### HC-NNN: <constraint title>
- **Added:** YYYY-MM-DD
- **Reason:** Why this constraint exists
- **Scope:** Which files/paths it applies to
- **Verify:** How to check compliance (grep, lint rule, test, etc.)
- **Last-validated:** YYYY-MM-DD (task: <task-id>)
- **Status:** ‚úÖ Active / ‚ö†Ô∏è STALE / ‚ùå Deprecated
EOF
    fi

    cat > "$baton_dir/tasks/_task-template/research.md" << 'EOF'
# Research: <task-id>

<!-- RESEARCH-STATUS: DRAFT -->

## Objective

## Scope

## Files reviewed

## Open questions
EOF

    cat > "$baton_dir/.gitignore" << 'EOF'
active-task
scratch/
tasks/*/
!tasks/_task-template/
EOF

    cmd_generate >/dev/null

    green "Initialized Baton v2 project at $baton_dir"
    echo "Next steps:"
    echo "  1. Edit .baton/project-config.json (add build/test commands)"
    echo "  2. Edit .baton/governance/hard-constraints.md (add project rules)"
    echo "  3. Edit .baton/review-checklists.md"
    echo "  4. Run: baton doctor"
}

cmd_doctor() {
    bold "Baton Doctor v${VERSION}\n"
    local layer="$(detect_layer)"
    local failed=0 passed=0 warned=0

    echo "Layer: $layer"
    echo

    # 1. Global layer
    if [ -d "$GLOBAL_ROOT/skills" ]; then
        green "Global layer: $GLOBAL_ROOT"
        passed=$((passed + 1))
    else
        red "Global layer not found ‚Äî run: baton install"
        failed=$((failed + 1))
    fi

    # 2. Skills check
    local expected_skills="plan-first-research plan-first-plan annotation-cycle context-slice plan-first-implement verification-gate code-reviewer using-baton"
    local missing_skills=""
    for skill in $expected_skills; do
        if [ ! -f "$GLOBAL_ROOT/skills/$skill/SKILL.md" ]; then
            missing_skills="$missing_skills $skill"
        fi
    done
    if [ -z "$missing_skills" ]; then
        green "All 8 skills present"
        passed=$((passed + 1))
    else
        red "Missing skills:$missing_skills"
        failed=$((failed + 1))
    fi

    # v2.1: Check workflow protocol
    if [ -f "$GLOBAL_ROOT/workflow-protocol.md" ]; then
        green "Workflow protocol: present"
        passed=$((passed + 1))
    else
        warn "Workflow protocol missing (expected at $GLOBAL_ROOT/workflow-protocol.md)"
        warned=$((warned + 1))
    fi

    # 3. Project layer
    if [ -d "$PROJECT_DIR" ]; then
        green "Project layer: $PROJECT_DIR"
        passed=$((passed + 1))
    else
        warn "No .baton/ in project ‚Äî Layer 0 only. Run 'baton init' for Layer 2."
        warned=$((warned + 1))
    fi

    # 4. Config
    if [ -f "$PROJECT_DIR/project-config.json" ]; then
        green "Project config found"
        passed=$((passed + 1))
        if grep -q '"regression"' "$PROJECT_DIR/project-config.json" 2>/dev/null; then
            green "Regression suites configured"
            passed=$((passed + 1))
        else
            warn "No regression suites configured"
            warned=$((warned + 1))
        fi
    else
        warn "No project-config.json (Layer 0 mode)"
        warned=$((warned + 1))
    fi

    # 5. Hard constraints
    if [ -f "$PROJECT_DIR/governance/hard-constraints.md" ]; then
        green "Hard constraints file present"
        passed=$((passed + 1))
        local stale_count=0
        while IFS= read -r line; do
            if echo "$line" | grep -q "^- \*\*Status:\*\* ‚ö†Ô∏è STALE"; then
                stale_count=$((stale_count + 1))
            fi
        done < "$PROJECT_DIR/governance/hard-constraints.md"
        if [ "$stale_count" -gt 0 ]; then
            warn "$stale_count stale constraint(s) detected"
            warned=$((warned + 1))
        fi
    else
        warn "No hard-constraints.md"
        warned=$((warned + 1))
    fi

    # 6. Hooks
    local hook="$GLOBAL_ROOT/hooks/session-start.sh"
    if [ -x "$hook" ]; then
        green "Session-start hook: executable"
        passed=$((passed + 1))
    elif [ -f "$hook" ]; then
        warn "Session-start hook exists but not executable"
        warned=$((warned + 1))
    else
        red "Session-start hook missing"
        failed=$((failed + 1))
    fi

    # 7. Active task
    if [ -f "$ACTIVE_FILE" ]; then
        local task=$(awk '{print $1}' "$ACTIVE_FILE")
        local full=$(detect_phase "$task")
        local base=$(echo "$full" | awk '{print $1}')
        echo "$task $base" > "$ACTIVE_FILE"
        green "Active task: $task ($full)"
        passed=$((passed + 1))
    else
        warn "No active task"
        warned=$((warned + 1))
    fi

    echo
    if [ $failed -eq 0 ]; then
        bold "All clear: $passed passed, $warned warnings"
    else
        bold "Issues found: $passed passed, $failed failed, $warned warnings"
        return 1
    fi
}

cmd_new_task() {
    local task_id="${1:-}"
    if [ -z "$task_id" ]; then red "Usage: baton new-task <id>"; return 1; fi
    local quick="${2:-}"
    local task_dir="$TASKS_DIR/$task_id"

    if [ -d "$task_dir" ]; then
        red "Task already exists: .baton/tasks/$task_id"
        return 1
    fi

    if [ ! -d "$PROJECT_DIR" ]; then
        mkdir -p "$PROJECT_DIR/tasks" "$PROJECT_DIR/scratch"
        warn "Created minimal .baton/ for task management (run 'baton init' for full Layer 2)"
    fi

    if [ -d "$TASKS_DIR/_task-template" ]; then
        cp -R "$TASKS_DIR/_task-template" "$task_dir"
        rm -f "$task_dir/plan.md" "$task_dir/verification.md" "$task_dir/reviews/review.md" 2>/dev/null || true
    else
        mkdir -p "$task_dir/reviews"
        echo "# Research: <task-id>" > "$task_dir/research.md"
    fi

    local initial_phase="research"
    local mode_str="research"
    if [ "$quick" = "--quick" ]; then
        echo "Quick-path task" > "$task_dir/.quick-path"
        initial_phase="plan"
        mode_str="quick-path"
    fi

    echo "$task_id $initial_phase" > "$ACTIVE_FILE"
    green "Created task: .baton/tasks/$task_id ($mode_str mode)"
}

cmd_active() {
    if [ "$1" = "--clear" ]; then
        rm -f "$ACTIVE_FILE"
        green "Active task cleared"
    elif [ -n "$1" ]; then
        local task_dir="$TASKS_DIR/$1"
        if [ ! -d "$task_dir" ]; then red "Task not found"; return 1; fi
        local full=$(detect_phase "$1")
        local base=$(echo "$full" | awk '{print $1}')
        echo "$1 $base" > "$ACTIVE_FILE"
        green "Active task set: $1 ($full)"
    else
        if [ -f "$ACTIVE_FILE" ]; then
            local task=$(awk '{print $1}' "$ACTIVE_FILE")
            local full=$(detect_phase "$task")
            local base=$(echo "$full" | awk '{print $1}')
            echo "$task $base" > "$ACTIVE_FILE"
            echo "Active task: $task ($full)"
        else
            echo "No active task."
        fi
    fi
}

# v2.1: cmd_next expanded with slice, review, approved phases
cmd_next() {
    if [ ! -f "$ACTIVE_FILE" ]; then
        echo "No active task."
        echo
        echo "Layer 0 ‚Äî standalone skills available:"
        echo "  baton research [scope]   Research a codebase area"
        echo "  baton plan [--from f]    Create a design plan"
        echo "  baton annotate [file]    Process plan annotations"
        echo "  baton slice [plan.md]    Generate context slices (context-slice skill)"
        echo "  baton verify             Run verification checks"
        echo "  baton review [opts]      Review code changes"
        echo
        echo "Or start a full workflow:  baton new-task <id>"
        return 0
    fi

    local task
    task="$(awk '{print $1}' "$ACTIVE_FILE" 2>/dev/null || echo "")"
    if [ -z "$task" ]; then
        echo "No active task."
        return 0
    fi

    local full base
    full="$(detect_phase "$task")"
    base="$(echo "$full" | awk '{print $1}')"
    echo "$task $base" > "$ACTIVE_FILE" 2>/dev/null || true

    echo "Active task: $task"
    echo "Phase: $full"
    echo

    local skill=""
    case "$base" in
        research)
            skill="plan-first-research"
            echo "Next:"
            echo "  - Write/confirm: .baton/tasks/$task/research.md"
            echo "  - When ready: set <!-- RESEARCH-STATUS: CONFIRMED --> and move to plan"
            ;;
        plan)
            skill="plan-first-plan"
            echo "Next:"
            echo "  - Write/revise design: .baton/tasks/$task/plan.md (no Todo yet)"
            echo "  - Ask for annotations/approval"
            ;;
        annotation)
            skill="annotation-cycle"
            echo "Next:"
            echo "  - Process every annotation in: .baton/tasks/$task/plan.md"
            echo "  - Supports [RESEARCH-GAP] for targeted supplemental research"
            echo "  - Update Annotation log; repeat until approved"
            ;;
        approved)
            skill="plan-first-plan"
            echo "Next:"
            echo "  - Generate Todo checklist from approved design"
            echo "  - Load plan-first-plan skill (Phase 2)"
            ;;
        slice)
            skill="context-slice"
            echo "Next:"
            echo "  - Generate context slices: load context-slice skill"
            echo "  - Target: .baton/tasks/$task/plan.md"
            ;;
        implement)
            if echo "$full" | grep -q "generating todo"; then
                skill="plan-first-plan"
                echo "Next:"
                echo "  - Append '## Todo' to: .baton/tasks/$task/plan.md"
                echo "  - Then generate context slices: baton slice .baton/tasks/$task/plan.md"
            elif echo "$full" | grep -q "sliced"; then
                skill="plan-first-implement"
                echo "Next:"
                echo "  - Implement todo items using context slices"
                echo "  - Each item gets its own focused context package"
            else
                skill="plan-first-implement"
                echo "Next:"
                echo "  - Implement todo items in: .baton/tasks/$task/plan.md"
                echo "  - Consider generating slices first: baton slice .baton/tasks/$task/plan.md"
            fi
            ;;
        verify)
            skill="verification-gate"
            echo "Next:"
            echo "  - Run configured build/tests/lint (see .baton/project-config.json)"
            echo "  - Run scope-based regression suites (if configured)"
            echo "  - Record evidence in: .baton/tasks/$task/verification.md"
            ;;
        review)
            skill="code-reviewer"
            echo "Next:"
            echo "  - Run code review against the plan"
            echo "  - Output: .baton/tasks/$task/review.md"
            ;;
        done)
            echo "Next:"
            echo "  - Start a new task: baton new-task <id>"
            echo "  - Or clear: baton active --clear"
            ;;
        abandoned)
            echo "Next:"
            echo "  - Start a new task: baton new-task <id>"
            echo "  - Or clear: baton active --clear"
            ;;
        *)
            echo "Next:"
            echo "  - Task state is unclear. Try: baton active $task"
            ;;
    esac

    if [ -n "$skill" ]; then
        echo
        echo "Skill: $skill"
        echo "Load: cat \"$GLOBAL_ROOT/skills/$skill/SKILL.md\""
    fi
}

cmd_abandon() {
    if [ -z "${1:-}" ]; then red "Usage: baton abandon <id>"; return 1; fi
    local task_dir="$TASKS_DIR/$1"
    if [ ! -d "$task_dir" ]; then red "Task not found"; return 1; fi
    touch "$task_dir/.abandoned"
    local curr=$(awk '{print $1}' "$ACTIVE_FILE" 2>/dev/null || echo "")
    if [ "$curr" = "$1" ]; then rm -f "$ACTIVE_FILE"; fi
    green "Abandoned task: $1"
}

cmd_reset_task() {
    if [ -z "${1:-}" ]; then red "Usage: baton reset-task <id>"; return 1; fi
    local task_dir="$TASKS_DIR/$1"
    if [ ! -d "$task_dir" ]; then red "Task not found"; return 1; fi
    rm -rf "$task_dir"
    cmd_new_task "$1" >/dev/null
    green "Reset task: $1"
}

cmd_constraints() {
    local constraints_file="$PROJECT_DIR/governance/hard-constraints.md"
    if [ ! -f "$constraints_file" ]; then
        red "No hard-constraints.md found. Run 'baton init' first."
        return 1
    fi

    bold "Hard Constraints Status\n"
    local total=0 active=0 stale=0 deprecated=0

    while IFS= read -r line; do
        if echo "$line" | grep -q "^### HC-"; then
            total=$((total + 1))
            local title="$line"
        fi
        if echo "$line" | grep -q "Status:.*Active"; then
            active=$((active + 1))
            green "$title"
        elif echo "$line" | grep -q "Status:.*STALE"; then
            stale=$((stale + 1))
            warn "$title (STALE)"
        elif echo "$line" | grep -q "Status:.*Deprecated"; then
            deprecated=$((deprecated + 1))
            echo "  ‚äò $title (deprecated)"
        fi
    done < "$constraints_file"

    echo
    bold "Total: $total | Active: $active | Stale: $stale | Deprecated: $deprecated"
}

cmd_generate() {
    local platforms="$(detect_platforms)"
    local skills=""
    if [ -d "$GLOBAL_ROOT/skills" ]; then
        skills=$(for f in "$GLOBAL_ROOT/skills/"*/SKILL.md; do
            [ -f "$f" ] || continue
            name=$(basename $(dirname "$f"))
            desc=$(awk 'BEGIN{f=0;p=""} /^description:/{f=1;next} f && /^  /{line=$0;gsub(/^  /,"",line);if(p=="")p=line;else p=p" "line;next} f && !/^  /{print p;exit}' "$f")
            echo "- **$name**: $desc"
        done)
    fi

    local agents_md="$REPO_ROOT/AGENTS.md"
    cat > "$agents_md" << EOF
# AGENTS.md
<!-- Auto-generated by: baton generate (v2.1) -->
This repository uses a **plan-first workflow** with three layers.

## Architecture
- **Layer 0**: Standalone skills (always available, no setup needed)
- **Layer 1**: Task workflow (baton new-task, adds phase-lock + gates)
- **Layer 2**: Project governance (baton init, adds constraints + regression)

## Skills
Baton skills are installed at \`~/.baton/skills/\`.
$skills

## Protocol
Workflow protocol (single source of truth for inter-skill relationships):
\`~/.baton/workflow-protocol.md\`

## Artifacts
All task artifacts live under \`.baton/tasks/<task-id>/\`.
EOF
    green "Generated $agents_md"

    if [[ " $platforms " == *" cursor "* ]]; then
        mkdir -p "$REPO_ROOT/.cursor/rules"
        cat > "$REPO_ROOT/.cursor/rules/baton.md" << EOF
---
description: Baton workflow ‚Äî auto-loaded for all code change tasks
globs:
alwaysApply: true
---
# Baton v2.1 ‚Äî Plan-First Workflow

You MUST follow the plan-first workflow for all non-trivial code changes.
Read \`.baton/active-task\` to find the current phase.
Load the FULL skill file from \`~/.baton/skills/\`.

## üõë Phase-Lock Rules (CRITICAL)
- If phase is \`research\`, \`plan\`, or \`annotation\`: You MUST NOT modify any file outside \`.baton/\`.
- You can ONLY modify source code if \`plan.md\` is \`<!-- STATUS: APPROVED -->\` **and** contains a \`## Todo\` checklist.
- In Layer 0 (no active task): phase-lock is not enforced, but discipline still applies.

## Phase-Lock Self-Enforcement (Cursor)

Cursor does not have a PreToolUse hook, so phase-lock must be self-enforced.

**Before every file modification, perform this check:**

1. Read \`.baton/active-task\` to get the current phase
2. If phase is research / plan / annotation:
   - **You MUST NOT modify any file outside .baton/**
   - If you are about to modify source code, STOP and inform the user
3. If phase is implement:
   - Read plan.md to confirm STATUS: APPROVED + ## Todo exists
   - If using context slices, confirm the target file is in "Files to modify"

**Violating this rule is equivalent to modifying unapproved code. This is a constraint, not a suggestion.**

$skills
EOF
        green "Generated $REPO_ROOT/.cursor/rules/baton.md"
    fi
}

cmd_version() {
    echo "Baton v${VERSION}"
    echo "Layer: $(detect_layer)"
}

# ‚îÄ‚îÄ Main ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

HELP="baton ‚Äî Plan-first workflow for AI-assisted development (v${VERSION})

Global:
    baton install          Install/update global layer to ~/.baton/
    baton version          Show version

Project:
    baton init             Initialize project layer (Layer 2)
    baton doctor           Health check (with constraint staleness)
    baton new-task <id>    Create task scaffold (--quick for fast path)
    baton active [<id>]    Show/switch active task (--clear to unset)
    baton next             Show the next step for the active task
    baton abandon <id>     Mark task as abandoned
    baton reset-task <id>  Reset task to fresh state
    baton generate         Generate platform files (AGENTS.md, etc.)
    baton constraints      Show hard constraints status

Layer 0 (standalone, no task needed):
    baton research <scope>           Deep-read code
    baton plan [--from research.md]  Design solution
    baton annotate <plan.md>         Process annotations
    baton slice <plan.md>            Generate context slices
    baton implement <plan.md>        Execute approved plan
    baton verify                     Run verification
    baton review [--diff HEAD~N]     Review changes"

if [ $# -eq 0 ]; then echo "$HELP"; exit 0; fi

case "$1" in
    install)    cmd_install ;;
    init)       cmd_init ;;
    doctor)     cmd_doctor ;;
    new-task)
        if [ "${2:-}" = "--quick" ]; then
            cmd_new_task "${3:-}" "--quick"
        elif [ "${3:-}" = "--quick" ]; then
            cmd_new_task "${2:-}" "--quick"
        else
            cmd_new_task "${2:-}" ""
        fi
        ;;
    active)     cmd_active "${2:-}" ;;
    next)       cmd_next ;;
    abandon)    cmd_abandon "${2:-}" ;;
    reset-task) cmd_reset_task "${2:-}" ;;
    generate)   cmd_generate ;;
    constraints) cmd_constraints ;;
    version)    cmd_version ;;
    research|plan|verify|review)
        echo "Skill: $(case "$1" in
            research) echo "plan-first-research" ;;
            plan) echo "plan-first-plan" ;;
            verify) echo "verification-gate" ;;
            review) echo "code-reviewer" ;;
        esac)"
        echo "In an AI environment, this skill is loaded automatically."
        echo "Read: $GLOBAL_ROOT/skills/.../SKILL.md"
        ;;
    annotate)
        if [ -z "${2:-}" ]; then
            red "Usage: baton annotate <plan.md>"
            exit 1
        fi
        if [ ! -f "${2}" ]; then
            red "File not found: ${2}"
            exit 1
        fi
        echo "Skill: annotation-cycle | Target: ${2}"
        ;;
    slice)
        if [ -z "${2:-}" ]; then
            red "Usage: baton slice <plan.md>"
            exit 1
        fi
        if [ ! -f "${2}" ]; then
            red "File not found: ${2}"
            exit 1
        fi
        if ! grep -q "## Todo" "${2}" 2>/dev/null; then
            red "No ## Todo section in: ${2}"
            echo "Plan must be APPROVED with a Todo checklist before slicing."
            exit 1
        fi
        echo "Skill: context-slice | Target: ${2}"
        ;;
    implement)
        if [ -n "${2:-}" ] && [ -f "${2}" ]; then
            if ! grep -q "STATUS: APPROVED" "${2}" 2>/dev/null; then
                warn "Plan not APPROVED: ${2}"
            fi
        fi
        echo "Skill: plan-first-implement"
        ;;
    -h|--help|help) echo "$HELP" ;;
    *) echo "Unknown command: $1"; echo "$HELP"; exit 1 ;;
esac
